// Generated by CoffeeScript 1.9.3
(function() {
  var PixSpy, app, argv, cluster, create, database, emptygif, express, fs, i, list, localConfig, numCPUs, server, trackGeo;

  PixSpy = (function() {
    function PixSpy(req1, res1) {
      this.req = req1;
      this.res = res1;
      this.generatedId = false;
      this.ip = this.req.headers['x-forwarded-for'] || this.req.connection.remoteAddress;
      this.id = this.req.params["id"] || this._generateId();
      this.ip = '122.161.157.158';
      if (global.mongoose === void 0) {
        global.mongoose = require('mongoose');
        global.mongoose.connect('mongodb://localhost/' + database);
        global.schema = new global.mongoose.Schema({
          ip: String,
          id: {
            type: String,
            index: true
          },
          geo: Object,
          hitHistory: {
            "type": Array,
            "default": new Array()
          },
          hitCount: {
            type: Number,
            "default": 0
          },
          lastHit: Date,
          updated_at: Date,
          created_at: {
            type: Date,
            "default": Date.now
          }
        });
        global.Ps = global.mongoose.model('Ps', global.schema);
        global.schema.pre('save', function(next) {
          this.created_at = new Date();
          return next();
        });
      }
      this.Ps = global.Ps;
      this.q = this.Ps.findOne({
        id: this.id
      }).exec();
    }

    PixSpy.prototype._generateId = function() {
      this.generatedId = true;
      return Math.random().toString(36).substr(2, 12);
    };

    PixSpy.prototype._trackSave = function(entry) {
      var hitCount, trackedInformation;
      trackedInformation = {
        ip: this.ip,
        geo: this.getGeoLocation(this.ip)
      };
      hitCount = entry.hitCount + 1;
      return this.Ps.update({
        id: entry.id
      }, {
        lastHit: new Date(),
        hitCount: hitCount,
        updated_at: new Date(),
        $push: {
          hitHistory: trackedInformation
        }
      }, {
        upsert: true
      }, function(err) {
        if (err) {
          return console.log(err);
        }
      });
    };

    PixSpy.prototype.track = function(entry) {
      entry = entry || false;
      if (entry) {
        return this._trackSave(entry);
      } else {
        return this.Ps.findOne({
          id: this.id
        }, function(err, entry) {
          if (err) {
            console.log(err);
          }
          return this.trackSave(entry);
        });
      }
    };

    PixSpy.prototype.list = function() {
      var self;
      self = this;
      return this.q.then(function(entry) {
        console.log(entry);
        if (!entry) {
          return self.res.send({
            image: false
          });
        } else {
          entry = entry.toObject();
          delete entry['_id'];
          delete entry['__v'];
          return self.res.send(entry);
        }
      });
    };

    PixSpy.prototype.create = function() {
      var entry;
      entry = new this.Ps();
      entry.id = this.id;
      entry.ip = this.ip;
      entry.geo = this.getGeoLocation(this.ip);
      entry.save();
      if (this.generatedId) {
        return this.list(entry);
      }
    };

    PixSpy.prototype._generateImage = function(id) {
      this.id = id != null ? id : this._generateId();
    };

    PixSpy.prototype.getGeoLocation = function(ip) {
      var geoip;
      geoip = require('geoip-lite');
      return this.geo = geoip.lookup(ip);
    };

    return PixSpy;

  })();

  cluster = require('cluster');

  numCPUs = require('os').cpus().length;

  argv = require('minimist')(process.argv.slice(2));

  argv['c'] = argv['c'] || false;

  if (argv['c'] && parseInt(argv['c']) <= numCPUs) {
    numCPUs = argv['c'] || numCPUs;
  }

  fs = require('fs');

  localConfig = JSON.parse(fs.readFileSync('config.json', 'utf8'));

  database = localConfig.database;

  trackGeo = localConfig.geo || false;

  if (cluster.isMaster) {
    i = 0;
    while (i < numCPUs) {
      cluster.fork();
      console.log('Starting Process app ' + i);
      i++;
    }
    cluster.on('exit', function(worker, code, signal) {
      console.log('worker ' + worker.process.pid + ' died, restarting');
      cluster.fork();
    });
  } else {
    express = require('express');
    app = express();
    emptygif = require('emptygif');
    create = function(req, res) {
      process.nextTick(function() {
        var pixSpy;
        pixSpy = new PixSpy(req, res);
        return pixSpy.q.then(function(entry) {
          if (entry === null) {
            return pixSpy.create();
          } else {
            return pixSpy.track(entry);
          }
        });
      });
      return emptygif.sendEmptyGif(req, res, {
        'Content-Type': 'image/gif',
        'Content-Length': emptygif.emptyGifBufferLength,
        'Cache-Control': 'public, max-age=0'
      });
    };
    list = function(req, res) {
      var pixSpy;
      pixSpy = new PixSpy(req, res);
      return pixSpy.list();
    };
    app.get('/create', function(req, res) {
      return create(req, res);
    });
    app.get('/create/:id.gif', function(req, res) {
      return create(req, res);
    });
    app.get('/list/:id.gif', function(req, res) {
      return list(req, res);
    });
    app.get('/:id.gif', function(req, res) {
      return create(req, res);
    });
    app.post('/gif', function(req, res) {
      return create(req, res);
    });
    app.post('/:id.gif', function(req, res) {
      return create(req, res);
    });
    server = app.listen(3000, function() {
      var host, port;
      host = server.address().address;
      port = server.address().port;
      console.log('App listening at http://%s:%s', host, port);
    });
  }

}).call(this);

//# sourceMappingURL=index.js.map
